// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bigbrain.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bigbrain_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bigbrain_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bigbrain_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bigbrain_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bigbrain_2eproto;
namespace bigbrain {
class AICapability;
class AICapabilityDefaultTypeInternal;
extern AICapabilityDefaultTypeInternal _AICapability_default_instance_;
class AICapabilityRequest;
class AICapabilityRequestDefaultTypeInternal;
extern AICapabilityRequestDefaultTypeInternal _AICapabilityRequest_default_instance_;
class AIModelContainer;
class AIModelContainerDefaultTypeInternal;
extern AIModelContainerDefaultTypeInternal _AIModelContainer_default_instance_;
class AIModelFramework;
class AIModelFrameworkDefaultTypeInternal;
extern AIModelFrameworkDefaultTypeInternal _AIModelFramework_default_instance_;
class AIModelIO;
class AIModelIODefaultTypeInternal;
extern AIModelIODefaultTypeInternal _AIModelIO_default_instance_;
class AIModelInformation;
class AIModelInformationDefaultTypeInternal;
extern AIModelInformationDefaultTypeInternal _AIModelInformation_default_instance_;
class AIModelsInformation;
class AIModelsInformationDefaultTypeInternal;
extern AIModelsInformationDefaultTypeInternal _AIModelsInformation_default_instance_;
class AIResponse;
class AIResponseDefaultTypeInternal;
extern AIResponseDefaultTypeInternal _AIResponse_default_instance_;
}  // namespace bigbrain
PROTOBUF_NAMESPACE_OPEN
template<> ::bigbrain::AICapability* Arena::CreateMaybeMessage<::bigbrain::AICapability>(Arena*);
template<> ::bigbrain::AICapabilityRequest* Arena::CreateMaybeMessage<::bigbrain::AICapabilityRequest>(Arena*);
template<> ::bigbrain::AIModelContainer* Arena::CreateMaybeMessage<::bigbrain::AIModelContainer>(Arena*);
template<> ::bigbrain::AIModelFramework* Arena::CreateMaybeMessage<::bigbrain::AIModelFramework>(Arena*);
template<> ::bigbrain::AIModelIO* Arena::CreateMaybeMessage<::bigbrain::AIModelIO>(Arena*);
template<> ::bigbrain::AIModelInformation* Arena::CreateMaybeMessage<::bigbrain::AIModelInformation>(Arena*);
template<> ::bigbrain::AIModelsInformation* Arena::CreateMaybeMessage<::bigbrain::AIModelsInformation>(Arena*);
template<> ::bigbrain::AIResponse* Arena::CreateMaybeMessage<::bigbrain::AIResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bigbrain {

enum AIModelIO_IOType : int {
  AIModelIO_IOType_OTHER = 0,
  AIModelIO_IOType_IMAGE = 1,
  AIModelIO_IOType_TEXT = 2,
  AIModelIO_IOType_AUDIO = 3,
  AIModelIO_IOType_GRAPH = 4,
  AIModelIO_IOType_VECTOR = 5,
  AIModelIO_IOType_MATRIX = 6,
  AIModelIO_IOType_BBOX = 7,
  AIModelIO_IOType_AIModelIO_IOType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AIModelIO_IOType_AIModelIO_IOType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AIModelIO_IOType_IsValid(int value);
constexpr AIModelIO_IOType AIModelIO_IOType_IOType_MIN = AIModelIO_IOType_OTHER;
constexpr AIModelIO_IOType AIModelIO_IOType_IOType_MAX = AIModelIO_IOType_BBOX;
constexpr int AIModelIO_IOType_IOType_ARRAYSIZE = AIModelIO_IOType_IOType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AIModelIO_IOType_descriptor();
template<typename T>
inline const std::string& AIModelIO_IOType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AIModelIO_IOType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AIModelIO_IOType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AIModelIO_IOType_descriptor(), enum_t_value);
}
inline bool AIModelIO_IOType_Parse(
    const std::string& name, AIModelIO_IOType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AIModelIO_IOType>(
    AIModelIO_IOType_descriptor(), name, value);
}
enum AIModelFramework_ModelFramework : int {
  AIModelFramework_ModelFramework_OTHER = 0,
  AIModelFramework_ModelFramework_TENSORFLOW = 1,
  AIModelFramework_ModelFramework_PYTORCH = 2,
  AIModelFramework_ModelFramework_AIModelFramework_ModelFramework_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AIModelFramework_ModelFramework_AIModelFramework_ModelFramework_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AIModelFramework_ModelFramework_IsValid(int value);
constexpr AIModelFramework_ModelFramework AIModelFramework_ModelFramework_ModelFramework_MIN = AIModelFramework_ModelFramework_OTHER;
constexpr AIModelFramework_ModelFramework AIModelFramework_ModelFramework_ModelFramework_MAX = AIModelFramework_ModelFramework_PYTORCH;
constexpr int AIModelFramework_ModelFramework_ModelFramework_ARRAYSIZE = AIModelFramework_ModelFramework_ModelFramework_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AIModelFramework_ModelFramework_descriptor();
template<typename T>
inline const std::string& AIModelFramework_ModelFramework_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AIModelFramework_ModelFramework>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AIModelFramework_ModelFramework_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AIModelFramework_ModelFramework_descriptor(), enum_t_value);
}
inline bool AIModelFramework_ModelFramework_Parse(
    const std::string& name, AIModelFramework_ModelFramework* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AIModelFramework_ModelFramework>(
    AIModelFramework_ModelFramework_descriptor(), name, value);
}
// ===================================================================

class AIModelIO :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AIModelIO) */ {
 public:
  AIModelIO();
  virtual ~AIModelIO();

  AIModelIO(const AIModelIO& from);
  AIModelIO(AIModelIO&& from) noexcept
    : AIModelIO() {
    *this = ::std::move(from);
  }

  inline AIModelIO& operator=(const AIModelIO& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIModelIO& operator=(AIModelIO&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIModelIO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIModelIO* internal_default_instance() {
    return reinterpret_cast<const AIModelIO*>(
               &_AIModelIO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AIModelIO* other);
  friend void swap(AIModelIO& a, AIModelIO& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIModelIO* New() const final {
    return CreateMaybeMessage<AIModelIO>(nullptr);
  }

  AIModelIO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIModelIO>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIModelIO& from);
  void MergeFrom(const AIModelIO& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIModelIO* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AIModelIO";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AIModelIO_IOType IOType;
  static constexpr IOType OTHER =
    AIModelIO_IOType_OTHER;
  static constexpr IOType IMAGE =
    AIModelIO_IOType_IMAGE;
  static constexpr IOType TEXT =
    AIModelIO_IOType_TEXT;
  static constexpr IOType AUDIO =
    AIModelIO_IOType_AUDIO;
  static constexpr IOType GRAPH =
    AIModelIO_IOType_GRAPH;
  static constexpr IOType VECTOR =
    AIModelIO_IOType_VECTOR;
  static constexpr IOType MATRIX =
    AIModelIO_IOType_MATRIX;
  static constexpr IOType BBOX =
    AIModelIO_IOType_BBOX;
  static inline bool IOType_IsValid(int value) {
    return AIModelIO_IOType_IsValid(value);
  }
  static constexpr IOType IOType_MIN =
    AIModelIO_IOType_IOType_MIN;
  static constexpr IOType IOType_MAX =
    AIModelIO_IOType_IOType_MAX;
  static constexpr int IOType_ARRAYSIZE =
    AIModelIO_IOType_IOType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  IOType_descriptor() {
    return AIModelIO_IOType_descriptor();
  }
  template<typename T>
  static inline const std::string& IOType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, IOType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function IOType_Name.");
    return AIModelIO_IOType_Name(enum_t_value);
  }
  static inline bool IOType_Parse(const std::string& name,
      IOType* value) {
    return AIModelIO_IOType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .bigbrain.AIModelIO.IOType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::bigbrain::AIModelIO_IOType type() const;
  void set_type(::bigbrain::AIModelIO_IOType value);

  // @@protoc_insertion_point(class_scope:bigbrain.AIModelIO)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AIModelFramework :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AIModelFramework) */ {
 public:
  AIModelFramework();
  virtual ~AIModelFramework();

  AIModelFramework(const AIModelFramework& from);
  AIModelFramework(AIModelFramework&& from) noexcept
    : AIModelFramework() {
    *this = ::std::move(from);
  }

  inline AIModelFramework& operator=(const AIModelFramework& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIModelFramework& operator=(AIModelFramework&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIModelFramework& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIModelFramework* internal_default_instance() {
    return reinterpret_cast<const AIModelFramework*>(
               &_AIModelFramework_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AIModelFramework* other);
  friend void swap(AIModelFramework& a, AIModelFramework& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIModelFramework* New() const final {
    return CreateMaybeMessage<AIModelFramework>(nullptr);
  }

  AIModelFramework* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIModelFramework>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIModelFramework& from);
  void MergeFrom(const AIModelFramework& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIModelFramework* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AIModelFramework";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AIModelFramework_ModelFramework ModelFramework;
  static constexpr ModelFramework OTHER =
    AIModelFramework_ModelFramework_OTHER;
  static constexpr ModelFramework TENSORFLOW =
    AIModelFramework_ModelFramework_TENSORFLOW;
  static constexpr ModelFramework PYTORCH =
    AIModelFramework_ModelFramework_PYTORCH;
  static inline bool ModelFramework_IsValid(int value) {
    return AIModelFramework_ModelFramework_IsValid(value);
  }
  static constexpr ModelFramework ModelFramework_MIN =
    AIModelFramework_ModelFramework_ModelFramework_MIN;
  static constexpr ModelFramework ModelFramework_MAX =
    AIModelFramework_ModelFramework_ModelFramework_MAX;
  static constexpr int ModelFramework_ARRAYSIZE =
    AIModelFramework_ModelFramework_ModelFramework_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModelFramework_descriptor() {
    return AIModelFramework_ModelFramework_descriptor();
  }
  template<typename T>
  static inline const std::string& ModelFramework_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModelFramework>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModelFramework_Name.");
    return AIModelFramework_ModelFramework_Name(enum_t_value);
  }
  static inline bool ModelFramework_Parse(const std::string& name,
      ModelFramework* value) {
    return AIModelFramework_ModelFramework_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // .bigbrain.AIModelFramework.ModelFramework framework = 1;
  void clear_framework();
  static const int kFrameworkFieldNumber = 1;
  ::bigbrain::AIModelFramework_ModelFramework framework() const;
  void set_framework(::bigbrain::AIModelFramework_ModelFramework value);

  // @@protoc_insertion_point(class_scope:bigbrain.AIModelFramework)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  int framework_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AICapability :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AICapability) */ {
 public:
  AICapability();
  virtual ~AICapability();

  AICapability(const AICapability& from);
  AICapability(AICapability&& from) noexcept
    : AICapability() {
    *this = ::std::move(from);
  }

  inline AICapability& operator=(const AICapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline AICapability& operator=(AICapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AICapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AICapability* internal_default_instance() {
    return reinterpret_cast<const AICapability*>(
               &_AICapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AICapability* other);
  friend void swap(AICapability& a, AICapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AICapability* New() const final {
    return CreateMaybeMessage<AICapability>(nullptr);
  }

  AICapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AICapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AICapability& from);
  void MergeFrom(const AICapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AICapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AICapability";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .bigbrain.AIModelInformation information = 1;
  bool has_information() const;
  void clear_information();
  static const int kInformationFieldNumber = 1;
  const ::bigbrain::AIModelInformation& information() const;
  ::bigbrain::AIModelInformation* release_information();
  ::bigbrain::AIModelInformation* mutable_information();
  void set_allocated_information(::bigbrain::AIModelInformation* information);

  // .bigbrain.AIModelContainer container = 2;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 2;
  const ::bigbrain::AIModelContainer& container() const;
  ::bigbrain::AIModelContainer* release_container();
  ::bigbrain::AIModelContainer* mutable_container();
  void set_allocated_container(::bigbrain::AIModelContainer* container);

  // @@protoc_insertion_point(class_scope:bigbrain.AICapability)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::bigbrain::AIModelInformation* information_;
  ::bigbrain::AIModelContainer* container_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AIModelInformation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AIModelInformation) */ {
 public:
  AIModelInformation();
  virtual ~AIModelInformation();

  AIModelInformation(const AIModelInformation& from);
  AIModelInformation(AIModelInformation&& from) noexcept
    : AIModelInformation() {
    *this = ::std::move(from);
  }

  inline AIModelInformation& operator=(const AIModelInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIModelInformation& operator=(AIModelInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIModelInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIModelInformation* internal_default_instance() {
    return reinterpret_cast<const AIModelInformation*>(
               &_AIModelInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AIModelInformation* other);
  friend void swap(AIModelInformation& a, AIModelInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIModelInformation* New() const final {
    return CreateMaybeMessage<AIModelInformation>(nullptr);
  }

  AIModelInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIModelInformation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIModelInformation& from);
  void MergeFrom(const AIModelInformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIModelInformation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AIModelInformation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bigbrain.AIModelIO inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  ::bigbrain::AIModelIO* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
      mutable_inputs();
  const ::bigbrain::AIModelIO& inputs(int index) const;
  ::bigbrain::AIModelIO* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
      inputs() const;

  // repeated .bigbrain.AIModelIO outputs = 6;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 6;
  ::bigbrain::AIModelIO* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
      mutable_outputs();
  const ::bigbrain::AIModelIO& outputs(int index) const;
  ::bigbrain::AIModelIO* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
      outputs() const;

  // repeated .bigbrain.AIModelIO update_inputs = 8;
  int update_inputs_size() const;
  void clear_update_inputs();
  static const int kUpdateInputsFieldNumber = 8;
  ::bigbrain::AIModelIO* mutable_update_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
      mutable_update_inputs();
  const ::bigbrain::AIModelIO& update_inputs(int index) const;
  ::bigbrain::AIModelIO* add_update_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
      update_inputs() const;

  // repeated .bigbrain.AIModelIO update_outputs = 9;
  int update_outputs_size() const;
  void clear_update_outputs();
  static const int kUpdateOutputsFieldNumber = 9;
  ::bigbrain::AIModelIO* mutable_update_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
      mutable_update_outputs();
  const ::bigbrain::AIModelIO& update_outputs(int index) const;
  ::bigbrain::AIModelIO* add_update_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
      update_outputs() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string description = 2;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);

  // string path = 3;
  void clear_path();
  static const int kPathFieldNumber = 3;
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // .bigbrain.AIModelFramework framework = 4;
  bool has_framework() const;
  void clear_framework();
  static const int kFrameworkFieldNumber = 4;
  const ::bigbrain::AIModelFramework& framework() const;
  ::bigbrain::AIModelFramework* release_framework();
  ::bigbrain::AIModelFramework* mutable_framework();
  void set_allocated_framework(::bigbrain::AIModelFramework* framework);

  // bool updateable = 7;
  void clear_updateable();
  static const int kUpdateableFieldNumber = 7;
  bool updateable() const;
  void set_updateable(bool value);

  // @@protoc_insertion_point(class_scope:bigbrain.AIModelInformation)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO > inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO > outputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO > update_inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO > update_outputs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::bigbrain::AIModelFramework* framework_;
  bool updateable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AIModelContainer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AIModelContainer) */ {
 public:
  AIModelContainer();
  virtual ~AIModelContainer();

  AIModelContainer(const AIModelContainer& from);
  AIModelContainer(AIModelContainer&& from) noexcept
    : AIModelContainer() {
    *this = ::std::move(from);
  }

  inline AIModelContainer& operator=(const AIModelContainer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIModelContainer& operator=(AIModelContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIModelContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIModelContainer* internal_default_instance() {
    return reinterpret_cast<const AIModelContainer*>(
               &_AIModelContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AIModelContainer* other);
  friend void swap(AIModelContainer& a, AIModelContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIModelContainer* New() const final {
    return CreateMaybeMessage<AIModelContainer>(nullptr);
  }

  AIModelContainer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIModelContainer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIModelContainer& from);
  void MergeFrom(const AIModelContainer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIModelContainer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AIModelContainer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);

  // string hash_model = 2;
  void clear_hash_model();
  static const int kHashModelFieldNumber = 2;
  const std::string& hash_model() const;
  void set_hash_model(const std::string& value);
  void set_hash_model(std::string&& value);
  void set_hash_model(const char* value);
  void set_hash_model(const char* value, size_t size);
  std::string* mutable_hash_model();
  std::string* release_hash_model();
  void set_allocated_hash_model(std::string* hash_model);

  // string hash_state = 3;
  void clear_hash_state();
  static const int kHashStateFieldNumber = 3;
  const std::string& hash_state() const;
  void set_hash_state(const std::string& value);
  void set_hash_state(std::string&& value);
  void set_hash_state(const char* value);
  void set_hash_state(const char* value, size_t size);
  std::string* mutable_hash_state();
  std::string* release_hash_state();
  void set_allocated_hash_state(std::string* hash_state);

  // string timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  const std::string& timestamp() const;
  void set_timestamp(const std::string& value);
  void set_timestamp(std::string&& value);
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  std::string* mutable_timestamp();
  std::string* release_timestamp();
  void set_allocated_timestamp(std::string* timestamp);

  // bytes model = 5;
  void clear_model();
  static const int kModelFieldNumber = 5;
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const void* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);

  // bytes state = 6;
  void clear_state();
  static const int kStateFieldNumber = 6;
  const std::string& state() const;
  void set_state(const std::string& value);
  void set_state(std::string&& value);
  void set_state(const char* value);
  void set_state(const void* value, size_t size);
  std::string* mutable_state();
  std::string* release_state();
  void set_allocated_state(std::string* state);

  // bytes other = 7;
  void clear_other();
  static const int kOtherFieldNumber = 7;
  const std::string& other() const;
  void set_other(const std::string& value);
  void set_other(std::string&& value);
  void set_other(const char* value);
  void set_other(const void* value, size_t size);
  std::string* mutable_other();
  std::string* release_other();
  void set_allocated_other(std::string* other);

  // @@protoc_insertion_point(class_scope:bigbrain.AIModelContainer)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timestamp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr other_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AICapabilityRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AICapabilityRequest) */ {
 public:
  AICapabilityRequest();
  virtual ~AICapabilityRequest();

  AICapabilityRequest(const AICapabilityRequest& from);
  AICapabilityRequest(AICapabilityRequest&& from) noexcept
    : AICapabilityRequest() {
    *this = ::std::move(from);
  }

  inline AICapabilityRequest& operator=(const AICapabilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AICapabilityRequest& operator=(AICapabilityRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AICapabilityRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AICapabilityRequest* internal_default_instance() {
    return reinterpret_cast<const AICapabilityRequest*>(
               &_AICapabilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AICapabilityRequest* other);
  friend void swap(AICapabilityRequest& a, AICapabilityRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AICapabilityRequest* New() const final {
    return CreateMaybeMessage<AICapabilityRequest>(nullptr);
  }

  AICapabilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AICapabilityRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AICapabilityRequest& from);
  void MergeFrom(const AICapabilityRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AICapabilityRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AICapabilityRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:bigbrain.AICapabilityRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AIModelsInformation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AIModelsInformation) */ {
 public:
  AIModelsInformation();
  virtual ~AIModelsInformation();

  AIModelsInformation(const AIModelsInformation& from);
  AIModelsInformation(AIModelsInformation&& from) noexcept
    : AIModelsInformation() {
    *this = ::std::move(from);
  }

  inline AIModelsInformation& operator=(const AIModelsInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIModelsInformation& operator=(AIModelsInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIModelsInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIModelsInformation* internal_default_instance() {
    return reinterpret_cast<const AIModelsInformation*>(
               &_AIModelsInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AIModelsInformation* other);
  friend void swap(AIModelsInformation& a, AIModelsInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIModelsInformation* New() const final {
    return CreateMaybeMessage<AIModelsInformation>(nullptr);
  }

  AIModelsInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIModelsInformation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIModelsInformation& from);
  void MergeFrom(const AIModelsInformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIModelsInformation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AIModelsInformation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bigbrain.AIModelInformation model_information = 1;
  int model_information_size() const;
  void clear_model_information();
  static const int kModelInformationFieldNumber = 1;
  ::bigbrain::AIModelInformation* mutable_model_information(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelInformation >*
      mutable_model_information();
  const ::bigbrain::AIModelInformation& model_information(int index) const;
  ::bigbrain::AIModelInformation* add_model_information();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelInformation >&
      model_information() const;

  // @@protoc_insertion_point(class_scope:bigbrain.AIModelsInformation)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelInformation > model_information_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bigbrain_2eproto;
};
// -------------------------------------------------------------------

class AIResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bigbrain.AIResponse) */ {
 public:
  AIResponse();
  virtual ~AIResponse();

  AIResponse(const AIResponse& from);
  AIResponse(AIResponse&& from) noexcept
    : AIResponse() {
    *this = ::std::move(from);
  }

  inline AIResponse& operator=(const AIResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AIResponse& operator=(AIResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AIResponse& default_instance();

  enum ResultCase {
    kModel = 3,
    kModelsInformation = 4,
    RESULT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AIResponse* internal_default_instance() {
    return reinterpret_cast<const AIResponse*>(
               &_AIResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AIResponse* other);
  friend void swap(AIResponse& a, AIResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AIResponse* New() const final {
    return CreateMaybeMessage<AIResponse>(nullptr);
  }

  AIResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AIResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AIResponse& from);
  void MergeFrom(const AIResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AIResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bigbrain.AIResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_bigbrain_2eproto);
    return ::descriptor_table_bigbrain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // .bigbrain.AICapability model = 3;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 3;
  const ::bigbrain::AICapability& model() const;
  ::bigbrain::AICapability* release_model();
  ::bigbrain::AICapability* mutable_model();
  void set_allocated_model(::bigbrain::AICapability* model);

  // .bigbrain.AIModelsInformation models_information = 4;
  bool has_models_information() const;
  void clear_models_information();
  static const int kModelsInformationFieldNumber = 4;
  const ::bigbrain::AIModelsInformation& models_information() const;
  ::bigbrain::AIModelsInformation* release_models_information();
  ::bigbrain::AIModelsInformation* mutable_models_information();
  void set_allocated_models_information(::bigbrain::AIModelsInformation* models_information);

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:bigbrain.AIResponse)
 private:
  class HasBitSetters;
  void set_has_model();
  void set_has_models_information();

  inline bool has_result() const;
  inline void clear_has_result();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  union ResultUnion {
    ResultUnion() {}
    ::bigbrain::AICapability* model_;
    ::bigbrain::AIModelsInformation* models_information_;
  } result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_bigbrain_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AIModelIO

// .bigbrain.AIModelIO.IOType type = 1;
inline void AIModelIO::clear_type() {
  type_ = 0;
}
inline ::bigbrain::AIModelIO_IOType AIModelIO::type() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelIO.type)
  return static_cast< ::bigbrain::AIModelIO_IOType >(type_);
}
inline void AIModelIO::set_type(::bigbrain::AIModelIO_IOType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:bigbrain.AIModelIO.type)
}

// string name = 2;
inline void AIModelIO::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelIO::name() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelIO.name)
  return name_.GetNoArena();
}
inline void AIModelIO::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelIO.name)
}
inline void AIModelIO::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelIO.name)
}
inline void AIModelIO::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelIO.name)
}
inline void AIModelIO::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelIO.name)
}
inline std::string* AIModelIO::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelIO.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelIO::release_name() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelIO.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelIO::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelIO.name)
}

// -------------------------------------------------------------------

// AIModelFramework

// .bigbrain.AIModelFramework.ModelFramework framework = 1;
inline void AIModelFramework::clear_framework() {
  framework_ = 0;
}
inline ::bigbrain::AIModelFramework_ModelFramework AIModelFramework::framework() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelFramework.framework)
  return static_cast< ::bigbrain::AIModelFramework_ModelFramework >(framework_);
}
inline void AIModelFramework::set_framework(::bigbrain::AIModelFramework_ModelFramework value) {
  
  framework_ = value;
  // @@protoc_insertion_point(field_set:bigbrain.AIModelFramework.framework)
}

// string version = 2;
inline void AIModelFramework::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelFramework::version() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelFramework.version)
  return version_.GetNoArena();
}
inline void AIModelFramework::set_version(const std::string& value) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelFramework.version)
}
inline void AIModelFramework::set_version(std::string&& value) {
  
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelFramework.version)
}
inline void AIModelFramework::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelFramework.version)
}
inline void AIModelFramework::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelFramework.version)
}
inline std::string* AIModelFramework::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelFramework.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelFramework::release_version() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelFramework.version)
  
  return version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelFramework::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelFramework.version)
}

// -------------------------------------------------------------------

// AICapability

// .bigbrain.AIModelInformation information = 1;
inline bool AICapability::has_information() const {
  return this != internal_default_instance() && information_ != nullptr;
}
inline void AICapability::clear_information() {
  if (GetArenaNoVirtual() == nullptr && information_ != nullptr) {
    delete information_;
  }
  information_ = nullptr;
}
inline const ::bigbrain::AIModelInformation& AICapability::information() const {
  const ::bigbrain::AIModelInformation* p = information_;
  // @@protoc_insertion_point(field_get:bigbrain.AICapability.information)
  return p != nullptr ? *p : *reinterpret_cast<const ::bigbrain::AIModelInformation*>(
      &::bigbrain::_AIModelInformation_default_instance_);
}
inline ::bigbrain::AIModelInformation* AICapability::release_information() {
  // @@protoc_insertion_point(field_release:bigbrain.AICapability.information)
  
  ::bigbrain::AIModelInformation* temp = information_;
  information_ = nullptr;
  return temp;
}
inline ::bigbrain::AIModelInformation* AICapability::mutable_information() {
  
  if (information_ == nullptr) {
    auto* p = CreateMaybeMessage<::bigbrain::AIModelInformation>(GetArenaNoVirtual());
    information_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bigbrain.AICapability.information)
  return information_;
}
inline void AICapability::set_allocated_information(::bigbrain::AIModelInformation* information) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete information_;
  }
  if (information) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      information = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, information, submessage_arena);
    }
    
  } else {
    
  }
  information_ = information;
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AICapability.information)
}

// .bigbrain.AIModelContainer container = 2;
inline bool AICapability::has_container() const {
  return this != internal_default_instance() && container_ != nullptr;
}
inline void AICapability::clear_container() {
  if (GetArenaNoVirtual() == nullptr && container_ != nullptr) {
    delete container_;
  }
  container_ = nullptr;
}
inline const ::bigbrain::AIModelContainer& AICapability::container() const {
  const ::bigbrain::AIModelContainer* p = container_;
  // @@protoc_insertion_point(field_get:bigbrain.AICapability.container)
  return p != nullptr ? *p : *reinterpret_cast<const ::bigbrain::AIModelContainer*>(
      &::bigbrain::_AIModelContainer_default_instance_);
}
inline ::bigbrain::AIModelContainer* AICapability::release_container() {
  // @@protoc_insertion_point(field_release:bigbrain.AICapability.container)
  
  ::bigbrain::AIModelContainer* temp = container_;
  container_ = nullptr;
  return temp;
}
inline ::bigbrain::AIModelContainer* AICapability::mutable_container() {
  
  if (container_ == nullptr) {
    auto* p = CreateMaybeMessage<::bigbrain::AIModelContainer>(GetArenaNoVirtual());
    container_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bigbrain.AICapability.container)
  return container_;
}
inline void AICapability::set_allocated_container(::bigbrain::AIModelContainer* container) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete container_;
  }
  if (container) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      container = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, container, submessage_arena);
    }
    
  } else {
    
  }
  container_ = container;
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AICapability.container)
}

// -------------------------------------------------------------------

// AIModelInformation

// string name = 1;
inline void AIModelInformation::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelInformation::name() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.name)
  return name_.GetNoArena();
}
inline void AIModelInformation::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelInformation.name)
}
inline void AIModelInformation::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelInformation.name)
}
inline void AIModelInformation::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelInformation.name)
}
inline void AIModelInformation::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelInformation.name)
}
inline std::string* AIModelInformation::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelInformation::release_name() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelInformation.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelInformation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelInformation.name)
}

// string description = 2;
inline void AIModelInformation::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelInformation::description() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.description)
  return description_.GetNoArena();
}
inline void AIModelInformation::set_description(const std::string& value) {
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelInformation.description)
}
inline void AIModelInformation::set_description(std::string&& value) {
  
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelInformation.description)
}
inline void AIModelInformation::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelInformation.description)
}
inline void AIModelInformation::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelInformation.description)
}
inline std::string* AIModelInformation::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.description)
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelInformation::release_description() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelInformation.description)
  
  return description_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelInformation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelInformation.description)
}

// string path = 3;
inline void AIModelInformation::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelInformation::path() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.path)
  return path_.GetNoArena();
}
inline void AIModelInformation::set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelInformation.path)
}
inline void AIModelInformation::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelInformation.path)
}
inline void AIModelInformation::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelInformation.path)
}
inline void AIModelInformation::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelInformation.path)
}
inline std::string* AIModelInformation::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelInformation::release_path() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelInformation.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelInformation::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelInformation.path)
}

// .bigbrain.AIModelFramework framework = 4;
inline bool AIModelInformation::has_framework() const {
  return this != internal_default_instance() && framework_ != nullptr;
}
inline void AIModelInformation::clear_framework() {
  if (GetArenaNoVirtual() == nullptr && framework_ != nullptr) {
    delete framework_;
  }
  framework_ = nullptr;
}
inline const ::bigbrain::AIModelFramework& AIModelInformation::framework() const {
  const ::bigbrain::AIModelFramework* p = framework_;
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.framework)
  return p != nullptr ? *p : *reinterpret_cast<const ::bigbrain::AIModelFramework*>(
      &::bigbrain::_AIModelFramework_default_instance_);
}
inline ::bigbrain::AIModelFramework* AIModelInformation::release_framework() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelInformation.framework)
  
  ::bigbrain::AIModelFramework* temp = framework_;
  framework_ = nullptr;
  return temp;
}
inline ::bigbrain::AIModelFramework* AIModelInformation::mutable_framework() {
  
  if (framework_ == nullptr) {
    auto* p = CreateMaybeMessage<::bigbrain::AIModelFramework>(GetArenaNoVirtual());
    framework_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.framework)
  return framework_;
}
inline void AIModelInformation::set_allocated_framework(::bigbrain::AIModelFramework* framework) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete framework_;
  }
  if (framework) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      framework = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, framework, submessage_arena);
    }
    
  } else {
    
  }
  framework_ = framework;
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelInformation.framework)
}

// repeated .bigbrain.AIModelIO inputs = 5;
inline int AIModelInformation::inputs_size() const {
  return inputs_.size();
}
inline void AIModelInformation::clear_inputs() {
  inputs_.Clear();
}
inline ::bigbrain::AIModelIO* AIModelInformation::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
AIModelInformation::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bigbrain.AIModelInformation.inputs)
  return &inputs_;
}
inline const ::bigbrain::AIModelIO& AIModelInformation::inputs(int index) const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.inputs)
  return inputs_.Get(index);
}
inline ::bigbrain::AIModelIO* AIModelInformation::add_inputs() {
  // @@protoc_insertion_point(field_add:bigbrain.AIModelInformation.inputs)
  return inputs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
AIModelInformation::inputs() const {
  // @@protoc_insertion_point(field_list:bigbrain.AIModelInformation.inputs)
  return inputs_;
}

// repeated .bigbrain.AIModelIO outputs = 6;
inline int AIModelInformation::outputs_size() const {
  return outputs_.size();
}
inline void AIModelInformation::clear_outputs() {
  outputs_.Clear();
}
inline ::bigbrain::AIModelIO* AIModelInformation::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.outputs)
  return outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
AIModelInformation::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:bigbrain.AIModelInformation.outputs)
  return &outputs_;
}
inline const ::bigbrain::AIModelIO& AIModelInformation::outputs(int index) const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.outputs)
  return outputs_.Get(index);
}
inline ::bigbrain::AIModelIO* AIModelInformation::add_outputs() {
  // @@protoc_insertion_point(field_add:bigbrain.AIModelInformation.outputs)
  return outputs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
AIModelInformation::outputs() const {
  // @@protoc_insertion_point(field_list:bigbrain.AIModelInformation.outputs)
  return outputs_;
}

// bool updateable = 7;
inline void AIModelInformation::clear_updateable() {
  updateable_ = false;
}
inline bool AIModelInformation::updateable() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.updateable)
  return updateable_;
}
inline void AIModelInformation::set_updateable(bool value) {
  
  updateable_ = value;
  // @@protoc_insertion_point(field_set:bigbrain.AIModelInformation.updateable)
}

// repeated .bigbrain.AIModelIO update_inputs = 8;
inline int AIModelInformation::update_inputs_size() const {
  return update_inputs_.size();
}
inline void AIModelInformation::clear_update_inputs() {
  update_inputs_.Clear();
}
inline ::bigbrain::AIModelIO* AIModelInformation::mutable_update_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.update_inputs)
  return update_inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
AIModelInformation::mutable_update_inputs() {
  // @@protoc_insertion_point(field_mutable_list:bigbrain.AIModelInformation.update_inputs)
  return &update_inputs_;
}
inline const ::bigbrain::AIModelIO& AIModelInformation::update_inputs(int index) const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.update_inputs)
  return update_inputs_.Get(index);
}
inline ::bigbrain::AIModelIO* AIModelInformation::add_update_inputs() {
  // @@protoc_insertion_point(field_add:bigbrain.AIModelInformation.update_inputs)
  return update_inputs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
AIModelInformation::update_inputs() const {
  // @@protoc_insertion_point(field_list:bigbrain.AIModelInformation.update_inputs)
  return update_inputs_;
}

// repeated .bigbrain.AIModelIO update_outputs = 9;
inline int AIModelInformation::update_outputs_size() const {
  return update_outputs_.size();
}
inline void AIModelInformation::clear_update_outputs() {
  update_outputs_.Clear();
}
inline ::bigbrain::AIModelIO* AIModelInformation::mutable_update_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelInformation.update_outputs)
  return update_outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >*
AIModelInformation::mutable_update_outputs() {
  // @@protoc_insertion_point(field_mutable_list:bigbrain.AIModelInformation.update_outputs)
  return &update_outputs_;
}
inline const ::bigbrain::AIModelIO& AIModelInformation::update_outputs(int index) const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelInformation.update_outputs)
  return update_outputs_.Get(index);
}
inline ::bigbrain::AIModelIO* AIModelInformation::add_update_outputs() {
  // @@protoc_insertion_point(field_add:bigbrain.AIModelInformation.update_outputs)
  return update_outputs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelIO >&
AIModelInformation::update_outputs() const {
  // @@protoc_insertion_point(field_list:bigbrain.AIModelInformation.update_outputs)
  return update_outputs_;
}

// -------------------------------------------------------------------

// AIModelContainer

// string hash = 1;
inline void AIModelContainer::clear_hash() {
  hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::hash() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.hash)
  return hash_.GetNoArena();
}
inline void AIModelContainer::set_hash(const std::string& value) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.hash)
}
inline void AIModelContainer::set_hash(std::string&& value) {
  
  hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.hash)
}
inline void AIModelContainer::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.hash)
}
inline void AIModelContainer::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.hash)
}
inline std::string* AIModelContainer::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.hash)
  return hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_hash() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.hash)
  
  return hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.hash)
}

// string hash_model = 2;
inline void AIModelContainer::clear_hash_model() {
  hash_model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::hash_model() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.hash_model)
  return hash_model_.GetNoArena();
}
inline void AIModelContainer::set_hash_model(const std::string& value) {
  
  hash_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.hash_model)
}
inline void AIModelContainer::set_hash_model(std::string&& value) {
  
  hash_model_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.hash_model)
}
inline void AIModelContainer::set_hash_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.hash_model)
}
inline void AIModelContainer::set_hash_model(const char* value, size_t size) {
  
  hash_model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.hash_model)
}
inline std::string* AIModelContainer::mutable_hash_model() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.hash_model)
  return hash_model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_hash_model() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.hash_model)
  
  return hash_model_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_hash_model(std::string* hash_model) {
  if (hash_model != nullptr) {
    
  } else {
    
  }
  hash_model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash_model);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.hash_model)
}

// string hash_state = 3;
inline void AIModelContainer::clear_hash_state() {
  hash_state_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::hash_state() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.hash_state)
  return hash_state_.GetNoArena();
}
inline void AIModelContainer::set_hash_state(const std::string& value) {
  
  hash_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.hash_state)
}
inline void AIModelContainer::set_hash_state(std::string&& value) {
  
  hash_state_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.hash_state)
}
inline void AIModelContainer::set_hash_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.hash_state)
}
inline void AIModelContainer::set_hash_state(const char* value, size_t size) {
  
  hash_state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.hash_state)
}
inline std::string* AIModelContainer::mutable_hash_state() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.hash_state)
  return hash_state_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_hash_state() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.hash_state)
  
  return hash_state_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_hash_state(std::string* hash_state) {
  if (hash_state != nullptr) {
    
  } else {
    
  }
  hash_state_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash_state);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.hash_state)
}

// string timestamp = 4;
inline void AIModelContainer::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::timestamp() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.timestamp)
  return timestamp_.GetNoArena();
}
inline void AIModelContainer::set_timestamp(const std::string& value) {
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.timestamp)
}
inline void AIModelContainer::set_timestamp(std::string&& value) {
  
  timestamp_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.timestamp)
}
inline void AIModelContainer::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.timestamp)
}
inline void AIModelContainer::set_timestamp(const char* value, size_t size) {
  
  timestamp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.timestamp)
}
inline std::string* AIModelContainer::mutable_timestamp() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.timestamp)
  return timestamp_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_timestamp() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.timestamp)
  
  return timestamp_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_timestamp(std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.timestamp)
}

// bytes model = 5;
inline void AIModelContainer::clear_model() {
  model_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::model() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.model)
  return model_.GetNoArena();
}
inline void AIModelContainer::set_model(const std::string& value) {
  
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.model)
}
inline void AIModelContainer::set_model(std::string&& value) {
  
  model_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.model)
}
inline void AIModelContainer::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.model)
}
inline void AIModelContainer::set_model(const void* value, size_t size) {
  
  model_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.model)
}
inline std::string* AIModelContainer::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.model)
  return model_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_model() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.model)
  
  return model_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.model)
}

// bytes state = 6;
inline void AIModelContainer::clear_state() {
  state_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::state() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.state)
  return state_.GetNoArena();
}
inline void AIModelContainer::set_state(const std::string& value) {
  
  state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.state)
}
inline void AIModelContainer::set_state(std::string&& value) {
  
  state_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.state)
}
inline void AIModelContainer::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.state)
}
inline void AIModelContainer::set_state(const void* value, size_t size) {
  
  state_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.state)
}
inline std::string* AIModelContainer::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.state)
  return state_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_state() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.state)
  
  return state_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.state)
}

// bytes other = 7;
inline void AIModelContainer::clear_other() {
  other_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIModelContainer::other() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelContainer.other)
  return other_.GetNoArena();
}
inline void AIModelContainer::set_other(const std::string& value) {
  
  other_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIModelContainer.other)
}
inline void AIModelContainer::set_other(std::string&& value) {
  
  other_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIModelContainer.other)
}
inline void AIModelContainer::set_other(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  other_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIModelContainer.other)
}
inline void AIModelContainer::set_other(const void* value, size_t size) {
  
  other_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIModelContainer.other)
}
inline std::string* AIModelContainer::mutable_other() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelContainer.other)
  return other_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIModelContainer::release_other() {
  // @@protoc_insertion_point(field_release:bigbrain.AIModelContainer.other)
  
  return other_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIModelContainer::set_allocated_other(std::string* other) {
  if (other != nullptr) {
    
  } else {
    
  }
  other_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), other);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIModelContainer.other)
}

// -------------------------------------------------------------------

// AICapabilityRequest

// -------------------------------------------------------------------

// AIModelsInformation

// repeated .bigbrain.AIModelInformation model_information = 1;
inline int AIModelsInformation::model_information_size() const {
  return model_information_.size();
}
inline void AIModelsInformation::clear_model_information() {
  model_information_.Clear();
}
inline ::bigbrain::AIModelInformation* AIModelsInformation::mutable_model_information(int index) {
  // @@protoc_insertion_point(field_mutable:bigbrain.AIModelsInformation.model_information)
  return model_information_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelInformation >*
AIModelsInformation::mutable_model_information() {
  // @@protoc_insertion_point(field_mutable_list:bigbrain.AIModelsInformation.model_information)
  return &model_information_;
}
inline const ::bigbrain::AIModelInformation& AIModelsInformation::model_information(int index) const {
  // @@protoc_insertion_point(field_get:bigbrain.AIModelsInformation.model_information)
  return model_information_.Get(index);
}
inline ::bigbrain::AIModelInformation* AIModelsInformation::add_model_information() {
  // @@protoc_insertion_point(field_add:bigbrain.AIModelsInformation.model_information)
  return model_information_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bigbrain::AIModelInformation >&
AIModelsInformation::model_information() const {
  // @@protoc_insertion_point(field_list:bigbrain.AIModelsInformation.model_information)
  return model_information_;
}

// -------------------------------------------------------------------

// AIResponse

// bool success = 1;
inline void AIResponse::clear_success() {
  success_ = false;
}
inline bool AIResponse::success() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIResponse.success)
  return success_;
}
inline void AIResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:bigbrain.AIResponse.success)
}

// string error = 2;
inline void AIResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AIResponse::error() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIResponse.error)
  return error_.GetNoArena();
}
inline void AIResponse::set_error(const std::string& value) {
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bigbrain.AIResponse.error)
}
inline void AIResponse::set_error(std::string&& value) {
  
  error_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bigbrain.AIResponse.error)
}
inline void AIResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bigbrain.AIResponse.error)
}
inline void AIResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bigbrain.AIResponse.error)
}
inline std::string* AIResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:bigbrain.AIResponse.error)
  return error_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AIResponse::release_error() {
  // @@protoc_insertion_point(field_release:bigbrain.AIResponse.error)
  
  return error_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AIResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:bigbrain.AIResponse.error)
}

// .bigbrain.AICapability model = 3;
inline bool AIResponse::has_model() const {
  return result_case() == kModel;
}
inline void AIResponse::set_has_model() {
  _oneof_case_[0] = kModel;
}
inline void AIResponse::clear_model() {
  if (has_model()) {
    delete result_.model_;
    clear_has_result();
  }
}
inline ::bigbrain::AICapability* AIResponse::release_model() {
  // @@protoc_insertion_point(field_release:bigbrain.AIResponse.model)
  if (has_model()) {
    clear_has_result();
      ::bigbrain::AICapability* temp = result_.model_;
    result_.model_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bigbrain::AICapability& AIResponse::model() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIResponse.model)
  return has_model()
      ? *result_.model_
      : *reinterpret_cast< ::bigbrain::AICapability*>(&::bigbrain::_AICapability_default_instance_);
}
inline ::bigbrain::AICapability* AIResponse::mutable_model() {
  if (!has_model()) {
    clear_result();
    set_has_model();
    result_.model_ = CreateMaybeMessage< ::bigbrain::AICapability >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bigbrain.AIResponse.model)
  return result_.model_;
}

// .bigbrain.AIModelsInformation models_information = 4;
inline bool AIResponse::has_models_information() const {
  return result_case() == kModelsInformation;
}
inline void AIResponse::set_has_models_information() {
  _oneof_case_[0] = kModelsInformation;
}
inline void AIResponse::clear_models_information() {
  if (has_models_information()) {
    delete result_.models_information_;
    clear_has_result();
  }
}
inline ::bigbrain::AIModelsInformation* AIResponse::release_models_information() {
  // @@protoc_insertion_point(field_release:bigbrain.AIResponse.models_information)
  if (has_models_information()) {
    clear_has_result();
      ::bigbrain::AIModelsInformation* temp = result_.models_information_;
    result_.models_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bigbrain::AIModelsInformation& AIResponse::models_information() const {
  // @@protoc_insertion_point(field_get:bigbrain.AIResponse.models_information)
  return has_models_information()
      ? *result_.models_information_
      : *reinterpret_cast< ::bigbrain::AIModelsInformation*>(&::bigbrain::_AIModelsInformation_default_instance_);
}
inline ::bigbrain::AIModelsInformation* AIResponse::mutable_models_information() {
  if (!has_models_information()) {
    clear_result();
    set_has_models_information();
    result_.models_information_ = CreateMaybeMessage< ::bigbrain::AIModelsInformation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:bigbrain.AIResponse.models_information)
  return result_.models_information_;
}

inline bool AIResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void AIResponse::clear_has_result() {
  _oneof_case_[0] = RESULT_NOT_SET;
}
inline AIResponse::ResultCase AIResponse::result_case() const {
  return AIResponse::ResultCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bigbrain

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bigbrain::AIModelIO_IOType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bigbrain::AIModelIO_IOType>() {
  return ::bigbrain::AIModelIO_IOType_descriptor();
}
template <> struct is_proto_enum< ::bigbrain::AIModelFramework_ModelFramework> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bigbrain::AIModelFramework_ModelFramework>() {
  return ::bigbrain::AIModelFramework_ModelFramework_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bigbrain_2eproto
